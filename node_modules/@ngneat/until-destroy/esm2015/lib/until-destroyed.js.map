{"version":3,"file":"until-destroyed.js","sourceRoot":"","sources":["../../../../../libs/until-destroy/src/lib/until-destroyed.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,SAAS,EAAE,MAAM,gBAAgB,CAAC;AAE3C,OAAO,EACL,iBAAiB,EACjB,SAAS,EACT,0BAA0B,EAC1B,4BAA4B,GAC7B,MAAM,aAAa,CAAC;AAMrB,SAAS,kCAAkC,CACzC,QAAa,EACb,iBAAyB,EACzB,MAAc;IAEd,MAAM,eAAe,GAAG,QAAQ,CAAC,iBAAiB,CAAC,CAAC;IAEpD,IAAI,SAAS,IAAI,OAAO,eAAe,KAAK,UAAU,EAAE;QACtD,MAAM,IAAI,KAAK,CACb,GAAG,QAAQ,CAAC,WAAW,CAAC,IAAI,kDAAkD,iBAAiB,EAAE,CAClG,CAAC;KACH;IAED,0BAA0B,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;IAE7C,QAAQ,CAAC,iBAAiB,CAAC,GAAG;QAC5B,8CAA8C;QAC9C,eAAe,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;QACvC,4BAA4B,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;QAC3C,iEAAiE;QACjE,mEAAmE;QACnE,2DAA2D;QAC3D,wCAAwC;QACxC,QAAQ,CAAC,iBAAiB,CAAC,GAAG,eAAe,CAAC;IAChD,CAAC,CAAC;AACJ,CAAC;AAED,MAAM,UAAU,cAAc,CAAI,QAAW,EAAE,iBAA2B;IACxE,OAAO,CAAI,MAAqB,EAAE,EAAE;QAClC,MAAM,MAAM,GAAG,SAAS,CAAI,iBAAiB,CAAC,CAAC;QAE/C,8DAA8D;QAC9D,8DAA8D;QAC9D,IAAI,OAAO,iBAAiB,KAAK,QAAQ,EAAE;YACzC,kCAAkC,CAAC,QAAQ,EAAE,iBAAiB,EAAE,MAAM,CAAC,CAAC;SACzE;aAAM;YACL,SAAS,IAAI,sBAAsB,CAAC,QAAQ,CAAC,CAAC;YAC9C,0BAA0B,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;SAC9C;QAED,OAAO,MAAM,CAAC,IAAI,CAAC,SAAS,CAAK,QAAgB,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;IAC9D,CAAC,CAAC;AACJ,CAAC;AAED,SAAS,sBAAsB,CAAC,QAA2B;IACzD,MAAM,SAAS,GAAG,MAAM,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC;IAClD,MAAM,gBAAgB,GAAG,CAAC,CAAC,iBAAiB,IAAI,SAAS,CAAC,CAAC;IAE3D,IAAI,gBAAgB,EAAE;QACpB,MAAM,IAAI,KAAK,CACb,8DAA8D;YAC5D,4EAA4E,CAC/E,CAAC;KACH;AACH,CAAC","sourcesContent":["import { Observable } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\n\nimport {\n  DECORATOR_APPLIED,\n  getSymbol,\n  createSubjectOnTheInstance,\n  completeSubjectOnTheInstance,\n} from './internals';\n\n// This will be provided through Terser global definitions by Angular CLI. This will\n// help to tree-shake away the code unneeded for production bundles.\ndeclare const ngDevMode: boolean;\n\nfunction overrideNonDirectiveInstanceMethod(\n  instance: any,\n  destroyMethodName: string,\n  symbol: symbol\n): void {\n  const originalDestroy = instance[destroyMethodName];\n\n  if (ngDevMode && typeof originalDestroy !== 'function') {\n    throw new Error(\n      `${instance.constructor.name} is using untilDestroyed but doesn't implement ${destroyMethodName}`\n    );\n  }\n\n  createSubjectOnTheInstance(instance, symbol);\n\n  instance[destroyMethodName] = function () {\n    // eslint-disable-next-line prefer-rest-params\n    originalDestroy.apply(this, arguments);\n    completeSubjectOnTheInstance(this, symbol);\n    // We have to re-assign this property back to the original value.\n    // If the `untilDestroyed` operator is called for the same instance\n    // multiple times, then we will be able to get the original\n    // method again and not the patched one.\n    instance[destroyMethodName] = originalDestroy;\n  };\n}\n\nexport function untilDestroyed<T>(instance: T, destroyMethodName?: keyof T) {\n  return <U>(source: Observable<U>) => {\n    const symbol = getSymbol<T>(destroyMethodName);\n\n    // If `destroyMethodName` is passed then the developer applies\n    // this operator to something non-related to Angular DI system\n    if (typeof destroyMethodName === 'string') {\n      overrideNonDirectiveInstanceMethod(instance, destroyMethodName, symbol);\n    } else {\n      ngDevMode && ensureClassIsDecorated(instance);\n      createSubjectOnTheInstance(instance, symbol);\n    }\n\n    return source.pipe(takeUntil<U>((instance as any)[symbol]));\n  };\n}\n\nfunction ensureClassIsDecorated(instance: InstanceType<any>): never | void {\n  const prototype = Object.getPrototypeOf(instance);\n  const missingDecorator = !(DECORATOR_APPLIED in prototype);\n\n  if (missingDecorator) {\n    throw new Error(\n      'untilDestroyed operator cannot be used inside directives or ' +\n        'components or providers that are not decorated with UntilDestroy decorator'\n    );\n  }\n}\n"]}