import { Subscription } from 'rxjs';
import { isPipe } from './ivy';
import { getSymbol, completeSubjectOnTheInstance, markAsDecorated, } from './internals';
function unsubscribe(property) {
    if (property instanceof Subscription) {
        property.unsubscribe();
    }
}
function unsubscribeIfPropertyIsArrayLike(property) {
    Array.isArray(property) && property.forEach(unsubscribe);
}
function decorateNgOnDestroy(ngOnDestroy, options) {
    return function () {
        var _a;
        // Invoke the original `ngOnDestroy` if it exists
        ngOnDestroy && ngOnDestroy.call(this);
        // It's important to use `this` instead of caching instance
        // that may lead to memory leaks
        completeSubjectOnTheInstance(this, getSymbol());
        // Check if subscriptions are pushed to some array
        if (options.arrayName) {
            return unsubscribeIfPropertyIsArrayLike(this[options.arrayName]);
        }
        // Loop through the properties and find subscriptions
        if (options.checkProperties) {
            for (const property in this) {
                if ((_a = options.blackList) === null || _a === void 0 ? void 0 : _a.includes(property)) {
                    continue;
                }
                unsubscribe(this[property]);
            }
        }
    };
}
function decorateProviderDirectiveOrComponent(type, options) {
    type.prototype.ngOnDestroy = decorateNgOnDestroy(type.prototype.ngOnDestroy, options);
}
function decoratePipe(type, options) {
    const def = type.Éµpipe;
    def.onDestroy = decorateNgOnDestroy(def.onDestroy, options);
}
export function UntilDestroy(options = {}) {
    return (type) => {
        if (isPipe(type)) {
            decoratePipe(type, options);
        }
        else {
            decorateProviderDirectiveOrComponent(type, options);
        }
        markAsDecorated(type);
    };
}
//# sourceMappingURL=until-destroy.js.map