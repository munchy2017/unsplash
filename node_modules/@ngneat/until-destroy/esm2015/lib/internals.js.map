{"version":3,"file":"internals.js","sourceRoot":"","sources":["../../../../../libs/until-destroy/src/lib/internals.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,OAAO,EAAE,MAAM,MAAM,CAAC;AAI/B;;;GAGG;AACH,MAAM,OAAO,GAAkB,MAAM,CAAC,WAAW,CAAC,CAAC;AAEnD;;GAEG;AACH,MAAM,CAAC,MAAM,iBAAiB,GAAkB,MAAM,CAAC,oBAAoB,CAAC,CAAC;AAE7E;;;;;;GAMG;AACH,MAAM,UAAU,SAAS,CAAI,iBAA2B;IACtD,IAAI,OAAO,iBAAiB,KAAK,QAAQ,EAAE;QACzC,OAAO,MAAM,CAAC,cAAc,iBAAiB,EAAE,CAAC,CAAC;KAClD;SAAM;QACL,OAAO,OAAO,CAAC;KAChB;AACH,CAAC;AAED,MAAM,UAAU,eAAe,CAC7B,IAA6E;IAE7E,4FAA4F;IAC5F,sDAAsD;IACtD,IAAI,CAAC,SAAS,CAAC,iBAAiB,CAAC,GAAG,IAAI,CAAC;AAC3C,CAAC;AAQD,MAAM,UAAU,0BAA0B,CAAC,QAAa,EAAE,MAAc;IACtE,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE;QACrB,QAAQ,CAAC,MAAM,CAAC,GAAG,IAAI,OAAO,EAAQ,CAAC;KACxC;AACH,CAAC;AAED,MAAM,UAAU,4BAA4B,CAAC,QAAa,EAAE,MAAc;IACxE,IAAI,QAAQ,CAAC,MAAM,CAAC,EAAE;QACpB,QAAQ,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,CAAC;QACxB,QAAQ,CAAC,MAAM,CAAC,CAAC,QAAQ,EAAE,CAAC;QAC5B,6DAA6D;QAC7D,8DAA8D;QAC9D,QAAQ,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC;KACzB;AACH,CAAC","sourcesContent":["import { InjectableType, ɵDirectiveType, ɵComponentType } from '@angular/core';\nimport { Subject } from 'rxjs';\n\nimport { PipeType } from './ivy';\n\n/**\n * Applied to instances and stores `Subject` instance when\n * no custom destroy method is provided.\n */\nconst DESTROY: unique symbol = Symbol('__destroy');\n\n/**\n * Applied to definitions and informs that class is decorated\n */\nexport const DECORATOR_APPLIED: unique symbol = Symbol('__decoratorApplied');\n\n/**\n * If we use the `untilDestroyed` operator multiple times inside the single\n * instance providing different `destroyMethodName`, then all streams will\n * subscribe to the single subject. If any method is invoked, the subject will\n * emit and all streams will be unsubscribed. We wan't to prevent this behavior,\n * thus we store subjects under different symbols.\n */\nexport function getSymbol<T>(destroyMethodName?: keyof T): symbol {\n  if (typeof destroyMethodName === 'string') {\n    return Symbol(`__destroy__${destroyMethodName}`);\n  } else {\n    return DESTROY;\n  }\n}\n\nexport function markAsDecorated<T>(\n  type: InjectableType<T> | PipeType<T> | ɵDirectiveType<T> | ɵComponentType<T>\n): void {\n  // Store this property on the prototype if it's an injectable class, component or directive.\n  // We will be able to handle class extension this way.\n  type.prototype[DECORATOR_APPLIED] = true;\n}\n\nexport interface UntilDestroyOptions {\n  blackList?: string[];\n  arrayName?: string;\n  checkProperties?: boolean;\n}\n\nexport function createSubjectOnTheInstance(instance: any, symbol: symbol): void {\n  if (!instance[symbol]) {\n    instance[symbol] = new Subject<void>();\n  }\n}\n\nexport function completeSubjectOnTheInstance(instance: any, symbol: symbol): void {\n  if (instance[symbol]) {\n    instance[symbol].next();\n    instance[symbol].complete();\n    // We also have to re-assign this property thus in the future\n    // we will be able to create new subject on the same instance.\n    instance[symbol] = null;\n  }\n}\n"]}